# -*- coding: utf-8 -*-
"""Problem_Solving.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uDt3nxe-wKzxYORrJVNFG9q86ZR5ATlp

**1. What is the difference between list and tuple in Python?**

List are mutable which means we can modify the elements by adding or removing elements or by replacing the values of existing element.  Lists are created using square brackets '[ ]'.

Tuple are immutable which means the elements cannot be changed after the tuple is created. Tuples are created using parentheses '( )'.

**2. Explain the concept of PEP 8 ?**

PEP 8 contribute to the creation of clean, readable, and consistent Python code. Eg - Functions and methods, Indentations, comments..

**3. What is the purpose of the __init__ method in Python classes?**

The purpose of the '__init__ method ' in python classes are to invoke the attributes of the object when an object is created.

**4. How does inheritance work in Python? Provide an example.**

Inheritance in Python allows a class (subclass) to inherit attributes and methods from another class (base class).
"""

class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def bark(self):
        print("Dog barks")

animal_instance = Animal()
dog_instance = Dog()
animal_instance.speak()
dog_instance.speak()
dog_instance.bark()

"""**5. Explain the difference between staticmethod and classmethod ?**

staticmethod: Decorator for a method that doesn't access the instance or class state.

classmethod: Decorator for a method that takes the class as its first argument, allowing access to class-level attributes.

**6. What is Polymorphism in Python? Give an example.**

Polymorphism in Python allows objects of different types to be treated as objects of a common type.
"""

class Cat:
    def speak(self):
        return "Meow"

class Dog:
    def speak(self):
        return "Woof"

def animal_sound(animal):
    return animal.speak()

cat_inst = Cat()
dog_inst = Dog()

print(animal_sound(cat_inst))
print(animal_sound(dog_inst))

"""**7. How do you handle exceptions in Python?**

In Python, exceptions are handled using try, except blocks.

**8. Explain the Global Interpreter Lock (GIL) in Python.**

**9. What is a decorator in Python? Provide an example**

In Python, a decorator is a function that takes another function and extends or modifies its behavior without explicitly changing its code.
"""

def my_decorator(func):
    def wrapper():
        print("Hi!")
        func()
        print("Hey!")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()

"""**10. How do you implement encapsulation in Python?**

Encapsulation in Python is implemented by using private and protected attributes and methods. Use a single underscore _ - protected, and use double underscores __  - private.

**11. Explain the concept of duck typing.**

Duck typing in Python means determining the type of an object based on its behavior (methods and properties)

**12. What is the difference between append() and extend() methods for lists?**

append() Method:

Adds a single element to the end of the list.

extend() Method:

Adds the elements of an iterable (another list) to the end of the list.

**13.How does the with statement work in Python?**

In Python, the with statement is used to simplify resource management, such as file handling or network connections.

**14. Discuss the use of self in Python classes.**

self as its first parameter to refer to the instance being initialized.

**15. Explain the purpose of the __slots__ attribute.**

**16. What is the difference between an instance variable and a class variable?**

Instance Variable:
Belongs to an instance of a class.
Each instance has its own copy of the variable.
Defined inside a method using self.

Class Variable:
Belongs to the class itself.
Shared among all instances of the class.
Defined outside any method in the class.

**17. How do you implement Encapsulation, Abstraction, Polymorphism?**

Encapsulation:
Use private and protected attributes with naming conventions.
Control access to data by defining getter and setter methods.

Abstraction:
Hide complex implementation details and expose only relevant functionalities.
Use abstract classes or interfaces to define a blueprint.

Polymorphism:
Allow objects of different types to be treated as objects of a common type.
Achieved through method overriding or operator overloading.

**18 . How do you Implement single level Inheritance, multiple level inheritance, multi level inheritance, Hybrid Inheritance**

**Single Level Inheritance:**
"""

class Parent:
    def show(self):
        print("Parent class method")

class Child(Parent):
    def display(self):
        print("Child class method")

child_instance = Child()
child_instance.show()
child_instance.display()

"""**Multiple Level Inheritance:**"""

class A:
    def method_A(self):
        print("Class A method")

class B:
    def method_B(self):
        print("Class B method")

class C(A, B):
    def method_C(self):
        print("Class C method")

c_instance = C()
c_instance.method_A()
c_instance.method_B()
c_instance.method_C()

"""**Multi-level Inheritance:**"""

class A:
    def method_A(self):
        print("Class A method")

class B(A):
    def method_B(self):
        print("Class B method")

class C(B):
    def method_C(self):
        print("Class C method")

c_instance = C()
c_instance.method_A()
c_instance.method_B()
c_instance.method_C()

"""**Hybrid Inheritance:**"""

class A:
    def method_A(self):
        print("Class A method")

class B(A):
    def method_B(self):
        print("Class B method")

class C(A):
    def method_C(self):
        print("Class C method")

class D(B, C):
    def method_D(self):
        print("Class D method")

d_instance = D()
d_instance.method_A()
d_instance.method_B()
d_instance.method_C()
d_instance.method_D()

